'''
Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/o66Is1ab4ho

Подвиг 8. Объявите класс с именем Rect (прямоугольник), объекты которого создаются командой:

r = Rect(x, y, width, height)

где x, y - координаты верхнего левого угла (любые числа); width, height - ширина и высота прямоугольника (положительные числа).

В каждом объекте класса Rect должны формироваться локальные атрибуты с именами: _x, _y, _width, _height и соответствующими значениями. Если переданные аргументы x, y (не числа) и width, height не положительные числа, то генерировать исключение командой:

raise ValueError('некорректные координаты и параметры прямоугольника')

В классе Rect реализовать метод:

def is_collision(self, rect): ...

который проверяет пересечение текущего прямоугольника с другим (с объектом rect). Если прямоугольники пересекаются, то должно генерироваться исключение командой:

raise TypeError('прямоугольники пересекаются')

Сформировать в программе несколько объектов класса Rect со следующими значениями:

0; 0; 5; 3
6; 0; 3; 5
3; 2; 4; 4
0; 8; 8; 1

Сохранить их в списке lst_rect. На основе списка lst_rect сформировать еще один список lst_not_collision, в котором должны быть объекты rect не пересекающиеся ни с какими другими объектами в списке lst_rect.

P.S. В программе требуется объявить только класс и списки. На экран выводить ничего не нужно.

Подсказка. Для определения пересечения двух прямоугольников, у которых стороны параллельны осям координат (как в этом подвиге) достаточно проверить, что верхняя грань первого прямоугольника находится ниже нижней грани второго, или нижняя грань первого прямоугольника выше верхней грани второго. И то же самое для вертикальных граней.Memory limit: 256 MBTime limit: 15 seconds

'''

#АЛГОРИТМ ПРОВЕРКИ ПЕРЕСЕЧЕНИЯ ДВУХ ПРЯМОУГОЛЬНИКОВ НА ПЛОСКОСТИ


class Rect:
    def __init__(self, x, y, width, height):
        self._x = x
        self._y = y
        self._width = width
        self._height = height
        # Находим координаты нижней правой точки.

    def __setattr__(self, key, value):
        # Осуществляет проверку корректности значений атрибутов.
        if (key in ('_x', '_y') and not (type(value) in (int, float))) or \
                (key in ('_width', '_height') and not (
                        (type(value) in (int, float)) and value > 0)):
            raise ValueError(
                'некорректные координаты и параметры прямоугольника')
        super().__setattr__(key, value)

    def is_collision(self, rect):
        #Если выполняется хоть одно условие, то прямоугольники не пересекаются (*ось 'y' направлена вниз)
        #x1 > x2 + w2
        #x2 > x1 + w1
        #y1 > y2 + h2
        #y2 > y1 + h1

        if not (self._x > rect._x + rect._width or\
               rect._x > self._x + self._width or\
               self._y > rect._y + rect._height or\
               rect._y > self._y + self._height):
            raise TypeError('прямоугольники пересекаются')



lst_rect = [Rect(*i) for i in [[0, 0, 5, 3], [6, 0, 3, 5], [3, 2, 4, 4], [0, 8, 8, 1]]]
lst_not_collision = list()

for obj in lst_rect:
    try:
        for neighb in list(filter(lambda x: x != obj, lst_rect)):
            obj.is_collision(neighb)
    except TypeError:
        continue
    else:
        lst_not_collision.append(obj)

print(lst_not_collision)

